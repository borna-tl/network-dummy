# Lab 4 Problem 1: UDP Ping Application IPv6

For this problem, we implement a UDP-based ping application using IPv6 addressing. The server (`udppings`) listens for UDP datagrams containing a 6-byte secret followed by a 4-byte sequence number. The client (`udppingc`) sends a sequence of ping requests and measures round-trip times (RTT) for replies from the server.

Some notes:

- For this problem, we are using UDP (`socket()`, `bind()`, `sendto()`, `recvfrom()`).
- We have a simple iterative server that responds directly to each datagram without forking.
- Client binds to a specific local port (`portnum2`), sends `pcount` ping packets, and uses `ualarm()` with 1234567 us timeout to detect lost requests.

## Repository layout (lab4/v1)

The implementation is split across small modules; function prototypes come from the header files in this directory.

- `udppings.c` (server main)
	- `main(int argc, char **argv)` — parse `port` and `secret`, call `setup_udp_server(port)`, and run `process_ping_requests(sockfd, secret)`.

- `udppingc.c` (client main)
	- `main(int argc, char **argv)` — parse `servip`, `portnum`, `secret`, `portnum2`, and `pcount`; call `setup_udp_client(servip, portnum2)` to create and bind the client socket; compute a random initial sequence number in [0,999]; call `send_ping_requests()` to perform pcount probes and collect RTTs; finally call `calculate_statistics()` to summarize results.

- `setup_udp_server.c` / `setup_udp_server.h`
	- `int setup_udp_server(int port)` — create a UDP socket, bind it to the specified `port` on INADDR_ANY, and return the socket fd (or -1 on error).

- `process_ping_requests.c` / `process_ping_requests.h`
	- `void process_ping_requests(int sockfd, const char *secret)` — iterative server loop: call `recvfrom()` to receive datagrams, verify the first 6 bytes match `secret`, and if valid `sendto()` a response back to the client's address containing the same payload (secret + sequence number) so the client can match replies.

- `setup_udp_client.c` / `setup_udp_client.h`
	- `int setup_udp_client(const char *server_ip, int client_port)` — create a UDP socket and bind it to `client_port` (the local port the client must use). Returns the socket fd or exits/returns -1 if bind fails.

- `send_ping_requests.c` / `send_ping_requests.h`
	- `void set_server_address(const char *server_ip, int server_port)` — helper to store the server sockaddr for use by send/recv calls.
	- `void send_ping_requests(int sockfd, const char *secret, unsigned int initial_seq, int pcount, double *rtt_array)` — send pcount ping datagrams starting with `initial_seq` (subsequent seqs incremented), use `ualarm()` to set a 1234567 us timeout before blocking `recvfrom()`, timestamp each send with `gettimeofday()`, and on valid reply cancel the alarm and record RTT in `rtt_array` (in microseconds); on timeout store 0 for that probe.

- `alarm_handler_udp.c` / `alarm_handler_udp.h`
	- `extern volatile sig_atomic_t alarm_sent_off;`
	- `void alarm_handler_udp(int sig)` — SIGALRM handler that sets `alarm_sent_off` to indicate a timeout and causes blocking `recvfrom()` to be interrupted.

- `install_alarm_handler_udp.c` / `install_alarm_handler_udp.h`
	- `int install_alarm_handler(void)` — helper to register `alarm_handler_udp` and return success/failure.

- `calculate_statistics.c` / `calculate_statistics.h`
	- `void calculate_statistics(const double *rtt_array, int pcount)` — compute and print summary statistics: min, max, average, and standard deviation of non-zero RTT samples. RTTs with value 0 indicate lost probes and are excluded from mean/stddev but counted in packet-loss statistics.

## Payload & byte-ordering

- Each packet payload is exactly 10 bytes: the 6-byte secret (ASCII, no NUL) followed by a 4-byte unsigned int sequence number in network byte order (big-endian). Use `htonl()`/`ntohl()` when converting the sequence number before placing it into the UDP payload or after extracting it.
- For this application the exact machine endianness matters for constructing the 4-byte sequence number, so we have to convert to network byte order before transmit and back to host order upon receipt.

## Bonus

- As mentioned, this implementation uses IPv6 sockets (`AF_INET6`, `struct sockaddr_in6`) and accepts IPv6 addresses as input for the client/server coordinates. In particular, our lab example uses link-local addresses that start with `fe80::`. Link-local addresses are only meaningful on a single network interface and therefore require a scope identifier (interface index) when used in an IPv6 `sockaddr_in6` or textual address representation.

- On Linux a link-local address typically requires a zone/index appended to the textual address (for example `fe80::abcd:1234%eth0`) or the `sin6_scope_id` field of `struct sockaddr_in6` must be set to the appropriate interface index. Interface names and indexes differ between machines and boots, so hardcoding a full link-local address will make the program fragile across different amber lab machines.

- To avoid hardcoding link-local interface indices, the code uses `if_nametoindex()` (declared in `<net/if.h>`) to translate a portable interface name (here `eth0`) to the correct numeric index at runtime, then stores that value in `sin6_scope_id` before calling `sendto()` / `recvfrom()`. This allows the same code and README examples to work across different amber lab machines without editing addresses or numeric scope IDs.

- If you provide a link-local address on the command line when starting the client, ensure you either include a textual zone (e.g., `fe80::...%eth0`) or the client is able to determine the intended interface and call `if_nametoindex()` (the provided client code does this). For global/unicast IPv6 addresses a scope id is not required.


## RTT measurement and timeout

- The client sets a 1234567 u seconds timer using `ualarm(1234567, 0)` before each `recvfrom()` call.
- Record the send time with `gettimeofday()` immediately before `sendto()` and compute RTT by subtracting that timestamp from the timestamp taken on successful `recvfrom()`. This yields microsecond resolution RTT estimates.
- If `recvfrom()` is interrupted by SIGALRM (errno == EINTR) or returns without a matching secret/sequence number (older sequence), treat the probe as lost and record RTT value 0 for that ping; then proceed with the next sequence number.

## Client sequence numbering

- The initial sequence number is chosen uniformly randomly from {0, 1, 2, ..., 999}. Each subsequent probe increments the sequence number by 1.

## Building

Run `make` in this directory to build `udppings` and `udppingc`. A `Makefile` in this directory compiles the object files and creates the two executables and provides a `clean` target.

Example:

```bash
cd lab4/v1
make
```

## Running

1. Start the server on machine A / terminal A:

```bash
./udppings <portnum> <secret>
```

2. On machine B / terminal B start the client (bind to a local of your choice):

```bash
./udppingc <servip> <portnum> <secret> <client_portnum> <pcount>
```

3. Observe per-probe output (sequence number, RTT in microseconds, and whether it timed out). At the end, the client prints statistics: sent, received, loss percentage, min/avg/max/stddev RTT.

## Testing and Final Notes

- Set pcount ≤ 100 during correctness tests.
- Finally, try to connect to a port that is occupied (you can do this using two machines, one of which is getting timeouts from the server), you will see that appropriate message is shown and you cannot connect.
- Verify that the server echoes back the exact payload and that the client only counts replies that both match the secret and the expected sequence number.

For example:
```bash
./udppings 5000 secret
```

2. On machine B / terminal B start the client (bind to a local of your choice):

```bash
./udppingc fe80::a6bb:6dff:fe44:ddb8 5000 secret 5001 10
```
(note that we can find the servip by running ```ifconfig -a```)

and the output is:
```
--- Ping Statistics ---
Packets sent: 10
Packets received: 10
Packet loss: 0.0%
RTT Avg = 322.60 us
RTT Min = 234.00 us
RTT Max = 463.00 us
RTT STD = 66.28 us
--- Ping Statistics ---
```